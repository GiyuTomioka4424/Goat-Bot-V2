const fs = require("fs");
const path = require("path");
const SHOP_FILE = path.join(__dirname, "userItems.json");

// Persistent State
if (!global.cgSystem) {
    global.cgSystem = { 
        stage: "closed", 
        pool: [], 
        startTime: 0, 
        timer: null 
    };
}

module.exports = {
    config: {
        name: "colorgame",
        aliases: ["cg"],
        version: "11.5",
        author: "Gab Yu",
        category: "gambling"
    },

    onStart: async function ({ message, args, event, usersData, permission, api }) {
        const { senderID, threadID } = event;
        const system = global.cgSystem;
        const colors = ["red", "blue", "yellow", "green", "pink", "white"];

        // --- ADMIN: RESET (Refund & Global Broadcast) ---
        if (args[0] === "reset") {
            if (permission < 1) return message.reply("âŒ Admins only.");
            if (system.stage === "closed") return message.reply("âš  No active round to reset.");

            clearTimeout(system.timer);
            for (const p of system.pool) {
                const u = await usersData.get(p.senderID);
                await usersData.set(p.senderID, { money: (u.money || 0) + p.bet });
            }

            const refundCount = system.pool.length;
            system.stage = "closed";
            system.pool = [];

            const threads = await api.getThreadList(100, null, ["INBOX"]);
            const groupThreads = threads.filter(t => t.isGroup);
            const resetMsg = `ğŸ”„ **ğ—–ğ—¢ğ—Ÿğ—¢ğ—¥ ğ—šğ—”ğ— ğ—˜: ğ—¥ğ—˜ğ—¦ğ—˜ğ—§ ğ—¡ğ—¢ğ—§ğ—œğ—–ğ—˜**\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâš  Match cancelled by Admin.\nğŸ’° **Refunds:** ${refundCount} players have been paid back.`;

            groupThreads.forEach(g => api.sendMessage(resetMsg, g.threadID));
            return;
        }

        // --- ACTION: STATUS ---
        if (args[0] === "status") {
            if (system.stage === "closed") return message.reply("ğŸŒˆ **ğ—–ğ—¢ğ—Ÿğ—¢ğ—¥ ğ—šğ—”ğ— ğ—˜**: ğ—–ğ—Ÿğ—¢ğ—¦ğ—˜ğ——");
            const limit = system.stage === "betting" ? 300000 : 120000;
            const remaining = Math.max(0, Math.ceil((limit - (Date.now() - system.startTime)) / 1000));
            return message.reply(`ğŸŒˆ **ğ—–ğ—š ğ—¦ğ—§ğ—”ğ—§ğ—¨ğ—¦**: ${system.stage.toUpperCase()}\nâ° Ends in: ${remaining}s\nğŸ‘¥ Players: ${system.pool.length}`);
        }

        // --- ADMIN: START ---
        if (args[0] === "start") {
            if (permission < 1) return message.reply("âŒ Admins only.");
            if (system.stage !== "closed") return message.reply("âš  Match in progress.");

            system.stage = "betting";
            system.pool = [];
            system.startTime = Date.now();

            const threads = await api.getThreadList(100, null, ["INBOX"]);
            const groupThreads = threads.filter(t => t.isGroup);
            const startMsg = "ğŸ“¢ ğ—–ğ—¢ğ—Ÿğ—¢ğ—¥ ğ—šğ—”ğ— ğ—˜: ğ—•ğ—˜ğ—§ğ—§ğ—œğ—¡ğ—š ğ—¢ğ—£ğ—˜ğ—¡\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ•’ ğŸ± ğ— ğ—¶ğ—»ğ˜‚ğ˜ğ—²ğ˜€ to place bets!\n\nğŸ’¡ **Usage:** `!cg <bet> <color>`\nğŸ“ **Examples:** `!cg 500 red` or `!cg 1000 blue`\nğŸ¨ **Colors:** red, blue, yellow, green, pink, white";

            groupThreads.forEach(g => api.sendMessage(startMsg, g.threadID));

            // Phase 1: End Betting
            system.timer = setTimeout(() => {
                if (system.pool.length === 0) {
                    system.stage = "closed";
                    groupThreads.forEach(g => api.sendMessage("ğŸ’¨ **ğ—–ğ—¢ğ—Ÿğ—¢ğ—¥ ğ—šğ—”ğ— ğ—˜**: Cancelled. No bets were placed.", g.threadID));
                    return;
                }

                system.stage = "ongoing";
                system.startTime = Date.now();
                groupThreads.forEach(g => api.sendMessage("ğŸš« **ğ—•ğ—˜ğ—§ğ—§ğ—œğ—¡ğ—š ğ—–ğ—Ÿğ—¢ğ—¦ğ—˜ğ——**\nğŸ² Dice are rolling! Results in 2 minutes...", g.threadID));

                // Phase 2: Results
                setTimeout(async () => {
                    const roll = [colors[Math.floor(Math.random()*6)], colors[Math.floor(Math.random()*6)], colors[Math.floor(Math.random()*6)]];
                    let winnerList = "";

                    for (const p of system.pool) {
                        const matches = roll.filter(c => c === p.chosen).length;
                        if (matches > 0) {
                            let winAmt = p.bet * (matches + 1);
                            let allInv = fs.existsSync(SHOP_FILE) ? JSON.parse(fs.readFileSync(SHOP_FILE, "utf8")) : {};
                            let inv = allInv[p.senderID] || {};
                            if (inv["Crystal Dice"]) winAmt *= 2;

                            const u = await usersData.get(p.senderID);
                            await usersData.set(p.senderID, { money: (u.money || 0) + winAmt });
                            winnerList += `âœ¨ ${p.name}: +$${winAmt.toLocaleString()} (${matches}x)\n`;
                        }
                    }

                    const finalResult = `ğŸ² ğ—–ğ—¢ğ—Ÿğ—¢ğ—¥ ğ—šğ—”ğ— ğ—˜ ğ—¥ğ—˜ğ—¦ğ—¨ğ—Ÿğ—§\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nResults: [ ${roll.join(" | ").toUpperCase()} ]\n\nğŸ“œ **ğ—ªğ—œğ—¡ğ—¡ğ—˜ğ—¥ğ—¦:**\n${winnerList || "No w